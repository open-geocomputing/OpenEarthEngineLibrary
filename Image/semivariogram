var inputs=[{name:'input',description:'single band image  or imageColelction on with to run the computation ', type:'ee.Image|ee.ImageCollection',optional:false},
            {name:'radius',description:'the half size of the windows use to get neighbours', type:'integer',defaultValue:10 ,optional:false},
            {name:'Return',description:'Return', type:'ee.FeatureCollection',defaultValue:null,optional:true}]
            
var reference={name:'kriging',license:'GPLv3', description:'Compute a gap filling interpolation uisng kriging. It return a function, or apply on an image if "image" is informed and return the result of the computation.'};

exports.createDocumentation=function(){ return {inputs:inputs, reference:reference};}

exports.createFunction=function(internal,relPath){
return function(){
    var inputDictionary=internal.readInputs(Array.prototype.slice.call(arguments,0),inputs,reference,relPath);
    internal.addRef(reference);
    
    var halfSize=inputDictionary.radius;
    
    var numberOfElement=(halfSize*2+1)*(halfSize*2+1);
    var kernel=ee.Kernel.square(halfSize)
    var imCol=ee.ImageCollection(inputDictionary.input)
    
    var ftC=imCol.map(function(im){
      var mask=im.mask().neighborhoodToArray({kernel:kernel, defaultValue:0});
      var r=im.unmask(0).neighborhoodToArray({kernel:kernel, defaultValue:0}).subtract(im).pow(2);
      
      
      var val=ee.Dictionary(r.reduceRegion({reducer:ee.Reducer.toList(), geometry:geometry, crs:r.projection()}));
      
      var sumVal=ee.Array.cat(ee.List(val.get(val.keys().get(0))),2).reduce(ee.Reducer.sum(),[2]);
      val=ee.Dictionary(mask.reduceRegion({reducer:ee.Reducer.toList(), geometry:geometry, crs:mask.projection()}));
      var sumMask=ee.Array.cat(ee.List(val.get(val.keys().get(0))),2).reduce(ee.Reducer.sum(),[2]);
      

      var X=ee.Array(ee.List.sequence(-halfSize,halfSize,1)).repeat(1, halfSize*2+1)//.reshape([-1]);
      var Y=ee.Array(ee.List.sequence(-halfSize,halfSize,1)).repeat(1, halfSize*2+1).transpose()//.reshape([-1]);
      var dist=ee.Array.cat([X,Y], 2).pow(2).reduce(ee.Reducer.sum(), [2]).sqrt();
      
      return ee.FeatureCollection(ee.Array.cat([sumVal,sumMask,dist],3).reshape([-1,3]).sort(dist.reshape([-1,1])).toList().map(function(val){
          return ee.Feature(null,ee.Dictionary.fromLists(['var','amount','distance'],ee.List(val)));
      }));
    });
    
    ftC=ftC.flatten();
    
    return ee.Join.saveAll('sameDistance').apply(ftC.distinct('distance'),ftC,ee.Filter.equals({leftField:'distance', rightField:'distance'}))
    .map(function(ft){
      var col=ee.FeatureCollection(ee.List(ft.get('sameDistance')))
      return ee.Feature(null,ee.Dictionary.fromLists(['ditance','var'],[ft.get('distance'),col.aggregate_sum('var').divide(col.aggregate_sum('amount'))]));
    })
  };
}

